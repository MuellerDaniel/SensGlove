
"""
Functions for data acquisition
"""
import numpy as np
import serial,string,time,subprocess,struct,select,sys

def serialAcquisition(serPort, fileName, offset, measNr, timeStamp = True):
    """function for acquiring data from the serial port

    Parameters
    ----------
    serPort : str
        Name of serial Port
    fileName : str
        Name of the .txt file, the data gets saved to
        Remember: the file contains a timestamp!
    offset : int
        first samples, that get neglected
    measNr : int
        total number of measurements
    timeStamp : bool
        whether to add timeStamp to file or not

    Returns
    -------
    magMat : np.array(shape[measNr,3])
        the recorded magnetic field in the x-, y-, z-direction

    """
    ser = serial.Serial(port=serPort, baudrate=9600, timeout=1)
    fl = open(fileName, 'w')
    startime = time.time()
    if timeStamp:
        fl.write("# measurement started at start_time " + str(start_time) + "\n")
    magMat = np.empty(shape=[0,3])
    b = np.array([0.,0.,0.])
    cnt = 0
    #measNr = 0
    #offset = 0
    try:
        while cnt < measNr + offset:
            message = ser.readline()
            print cnt
            #print message
            if(cnt < offset):
                #cnt+=1
                print "too small..."
            else:
              #  print "recording... taking " + str(measNr) + " measurements"
                mlist = string.split(message, "\t")
                #print message
                if len(mlist) > 2:
                    try:
                        b[0] = 1*float(mlist[0])
                        b[1] = 1*float(mlist[1])
                        b[2] = 1*float(mlist[2])
                    except ValueError:
                        print 'float conversion not possible ', mlist
                else:
                    pass

                #print "mean[uT]: ", np.mean(b)
                magMat = np.append(magMat, [b])
                #print b
                if timeStamp:
                    fl.write(format((time.time()-start_time), '.3f') + "\t" +
                                str(b[0]) + "\t" + str(b[1]) + "\t" + str(b[2]) + "\n")
                else:
                    fl.write(str(b[0]) + "\t" + str(b[1]) + "\t" + str(b[2]) + "\n")
            cnt+=1


    # to catch a ctrl-c
    except KeyboardInterrupt:
        print "here!"
        #pass

    print str(cnt-offset) + " measurements taken"
    magMat = np.reshape(magMat, (magMat.size/3, 3))
    fl.close()
    ser.close()

    return magMat


def saveToFile(data,fileName):
    ''' Takes a n x 4 array and writes it to a file '''

    try:
        fl = open(fileName,'w')
    except IOError:
        print "sth went wrong..."
    for i in data:
            fl.write(str(i[0]) + "\t" +
                    str(i[1]) + "\t" +
                    str(i[2]) + "\t" +
                    str(i[3]) + "\n")
    fl.close()


def textAcquisition(fileName, timeStamp = False):
    """function for acquiring data from a text file

    Parameters
    ----------
    fileName : str
        name of .txt file of your data
    timeStamp : bool
        if you have a timeStamp in your data, assign it also in your mat

    Returns
    -------
    dataMat : np.array(shape[NrOfSensors,NrOfMeas, 4])
        timestamp of measurement(if written), magnetic field in x-, y-,z-direction

    """
    try:
        f = open(fileName, 'r')
    except IOError:
        print "File not found!"

    line = f.readline()
    dataMat = [[0.,0.,0.,0.]]
    form = 4
    while(line != ""):
        if (line.startswith("#")):
            print line
        else:
            dataString = string.split(line, "\t")

        if form == 4:
            dataMat = np.append(dataMat,
                            [[float(dataString[0]),
                              float(dataString[1]),
                              float(dataString[2]),
                              float(dataString[3])]],axis=0)
        elif form == 3:
             dataMat = np.append(dataMat,
                            [[float(dataString[1]),
                              float(dataString[2]),
                              float(dataString[3])]],axis=0)

        line = f.readline()
#    dataMat = dataMat[1:]
    dataMat = sortData(dataMat)
    return dataMat



def readLeap(leapF):
    ''' Read in the stateFile, generated by Leap
    Dataformat:
    leap timestamp MCP_Index PIP_Index DIP_Index phi_Index MCP_Middle PIP_Middle phi_Middle...
    avg data rate of leap: 110Hz (1/110 = 0.009s between two meas)

    Return
    ------
        tuple (timeStamps, anglesIndex, anglesMiddle, anglesRing, anglesPinky)'''

    num_lines = sum(1 for line in open(leapF))

    angInd = np.zeros((num_lines,4))
    angMid = np.zeros((num_lines,4))
    angRin = np.zeros((num_lines,4))
    angPin = np.zeros((num_lines,4))
    timeStamps = np.zeros((num_lines,))

    f = open(leapF,'r')
#    oldTime = int(f.readline().split()[0])
    timeStamps[0] = 0


    cnt = 0
    for i in f:
        line = i.split()
        if cnt == 0:
            startT = float(line[1])
            print "here"
        else:
            timeStamps[cnt] = (float(line[1])-startT)*1e-6

        line = line[2:]
        angInd[cnt] = np.array(line[0:4] ,dtype=np.float)
        angMid[cnt] = np.array(line[4:8] ,dtype=np.float)
        angRin[cnt] = np.array(line[8:12] ,dtype=np.float)
        angPin[cnt] = np.array(line[12:],dtype=np.float)

        cnt += 1


    return (timeStamps, angInd, angMid, angRin, angPin)


def readMag(magF):
    ''' Dataformat:
    timestamp B0_x B0_y B0_z B1_x B1_y B1_z ...
    avg data rate of mag system: 14Hz (1/14 = 0.07s between two meas)

    Return
    ------
        tuple (timeStamps, s1, s2, s3, s4) '''

    num_lines = sum(1 for line in open(magF))

    s1 = np.zeros((num_lines,3))
    s2 = np.zeros((num_lines,3))
    s3 = np.zeros((num_lines,3))
    s4 = np.zeros((num_lines,3))
    timeStamps = np.zeros((num_lines,))

    f = open(magF,'r')

    timeStamps[0] = 0

    cnt = 0
    for i in f:
        line = i.split()
        if cnt == 0:
            startT = float(line[0])
        else:
            timeStamps[cnt] = (float(line[0])-startT)
        line = line[1:]
        s1[cnt] = np.array(line[:3], dtype=np.float)
        s2[cnt] = np.array(line[3:6], dtype=np.float)
        s3[cnt] = np.array(line[6:9], dtype=np.float)
        s4[cnt] = np.array(line[9:], dtype=np.float)

        cnt += 1

    return (timeStamps, s1, s2, s3, s4)


def structDataBLE(inp):
    dataHex = []
    #print "STRUCTINPUT inp ", inp
    inp = inp.split()
    for x in inp:
        if len(x) == 2:
            dataHex.append(x)
    if ((len(dataHex)<=0) or (len(dataHex)%4)) :
#        print 'not enough numbers!'
#        print dataHex
        return np.array([0.,0.,0.,0.])

    dataHex = [chr(int(x, base=16)) for x in dataHex]
    d = []
    tmp = []
    value = np.array([0., 0., 0., 0.])
    i=0
    for i in range(len(dataHex)/4):
        d.append("".join(dataHex[(i*4):(i*4)+4]))
        tmp.append(struct.unpack("f", d[i]))
        value[i] = "{0:.2f}".format(float(tmp[i][0]))
        #i+=1

#    print "pipe: ", value
    return value


def structDataSer(data):
    b = np.array([0.,0.,0.,0.])
    data = data.split('\t')
    if len(data) == 3:
            try:
                b[1] = 1*float(data[0])
                b[2] = 1*float(data[1])
                b[3] = 1*float(data[2])
                return b
                #print "value: ", b
            except ValueError:
                print 'float conversion not possible ', data
                return np.array([0.,0.,0.])
    elif len(data) == 4:
        b[0] = float(data[0])
        b[1] = 1*float(data[1])
        b[2] = 1*float(data[2])
        b[3] = 1*float(data[3])
        return b


def eraseZeros(data):
    cnt=0
    for i in data:
        if i[1:].any() == False:
            data = np.delete(data, cnt, 0)
            cnt-=1
        cnt+=1
    return data

def sortData(data):
    ''' you return ONE matrix of shape=((nrSens,nrMeas,3))'''
    # erasing the first [0.,0.,0.] in the dataarray
    cnt=0
    for i in data:
        if i[1:].any() == False:
            data = np.delete(data, cnt, 0)
            cnt-=1
        cnt+=1
    # removing surplus taken measurements
    nrSens = int(max(data[:,0])+1)
    if len(data)%nrSens:
        print "too much  measurements taken...", len(data)%nrSens
        datadel = np.delete(data, np.s_[-1*(len(data)%nrSens):], axis=0)
#        print datadel.shape
#        np.reshape(datadel,(nrSens,len(datadel),3))
        data = None
        data = datadel
    # matrix for results
    s=np.zeros((nrSens, (len(data)/nrSens), 3))
#    print s.shape
#    cnt = np.zeros(shape=(nrSens,1), dtype=np.int)
    cnt = np.zeros((nrSens,1))
    for j in data:
        try:
            s[int(j[0])][int(cnt[int(j[0])])] = j[1:]
            cnt[int(j[0])] += 1
        except:
            print "error!!!", j
    return s

def splitData(data):
    ''' returns a list with the 4 sensor values '''
    one = np.array([0.,0.,0.])
    two = np.array([0.,0.,0.])
    three = np.array([0.,0.,0.])
    four = np.array([0.,0.,0.])
#    print "data: ",data.shape

    for i in data:
        if i[0] == 0:
            one = np.append(one,i[1:])
#            print "one!"
        elif i[0] == 1:
            two = np.append(two,i[1:])
        elif i[0] == 2:
            three = np.append(three,i[1:])
        elif i[0] == 3:
            four = np.append(four,i[1:])

    one = np.reshape(one,((len(one)/3,3)))
    two = np.reshape(two,((len(two)/3,3)))
    three = np.reshape(three,((len(three)/3,3)))
    four = np.reshape(four,((len(four)/3,3)))

    return (one[1:],two[1:],three[1:],four[1:])


def pipeAcquisition(arg, nrSens, fileName=None, measNr=None, offset=0):
    """function for acquiring data via pipe

    Parameters
    ----------
    args : str
        terminal command, to start the data acquisition

        "stty -F /dev/ttyUSB0 time 50; cat /dev/ttyUSB0" for serial

        "gatttool -t random -b E3:C0:07:76:53:70 --char-write-req --handle=0x000f --value=0300 --listen" for ble
    fileName : str
        name of the file, the data should be stored in (optional)

    measNr : int
        Number of measurements, that should be taken

    nrSens : int
        Number of active sensors

    Returns
    -------
    dataMat : np.array(shape[NrOfMeas, 3])
        magnetic field in x-, y-,z-direction

    """

    mat = np.array([[0.,0.,0.,0.]])
    if "/dev/tty" in arg:
        proc = subprocess.Popen(arg, stdout=subprocess.PIPE,
                                close_fds=True, shell=True)
    if "gatttool" in arg:
        proc = subprocess.Popen(arg.split(),
                                stdout=subprocess.PIPE, close_fds=True)
    i=0
    data = np.array([0.,0.,0.,0.])
    if measNr == None:
        measNr = np.inf
    try:
        while i<measNr*nrSens+offset:

            output = proc.stdout.readline()
            if output != '':
                if "gatttool" in arg:
                    data = structDataBLE(output)
                if "/dev/tty" in arg:
                    data = structDataSer(output)
                    print "ser data: ", data
                    if data == None: continue
                if (i>offset):
                    print i-offset, "measurements taken"
                else: print "BELOW OFFSET ", i
                print "data: ",data
                if data[0] == (mat[-1][0]+1)%nrSens:
                    mat = np.append(mat, [data], axis=0)
                else:   #
                    print "!!!!!!!!!!!!!!!!!!!!!!!!!oh no!!!!!!!!!!!!!!!!!!!!!!!!!"   #
                    i -= 1

            else :
                proc.stdout.close()
                proc.kill()
                break
            i += 1

    except KeyboardInterrupt:
        print "here!"
        proc.stdout.close()
        proc.kill()

    proc.stdout.close()
    proc.kill()

    mat = mat[offset+2:]
    if fileName != None:
        saveToFile(mat,fileName)
    mat = sortData(mat)

    return mat


def readMagPacket(proc, sensStamp=True):
    if sensStamp:
        mat = np.zeros((4,4))
        dlist = [0,1,2,3]
        while dlist:
            data = structDataBLE(proc.stdout.readline())
            try:
                dlist.remove(int(data[0]))
                mat[int(data[0])] = data
            except:
                continue

        return mat

    else:
        mat = np.zeros((4,3))
        dlist = [0,1,2,3]
        while dlist:
            data = structDataBLE(proc.stdout.readline())
            try:
                dlist.remove(int(data[0]))
                mat[int(data[0])] = data[1:]
            except:
                continue
        return mat




def RTdata_blocking(proc):
    mat = np.zeros((4,4))
    cnt = 0
    while cnt < 4:
        data = structDataBLE(proc.stdout.readline())
#        print data
        if data[0] == cnt:
            mat[cnt] = data
            cnt += 1
        else:       # no data
            print "here"
            continue

    return mat

def RTdata(data,proc):
    """function for acquiring sensor data of mux
        you only update the measurement, that you actually get
        NONBLOCKING version

    Parameters
    ----------
    data : array (shape=(4,4))
        array, where you save the data

    proc : subprocess
        the subprocess, which acquires the data (BLE or serial)

    Returns
    -------
    data : array (shape=(4,4))
        the updated data array

    """
    tmpData = np.array([0.,0.,0.,0.])
    while proc.stdout in select.select([proc.stdout], [], [], 0)[0]:
      line = proc.stdout.readline()
#      print "line in RT: ", line
      if line != ' ':
        tmpData = structDataBLE(line)
        if tmpData[0] == 0: data[0][1:] = tmpData[1:]
        if tmpData[0] == 1: data[1][1:] = tmpData[1:]
        if tmpData[0] == 2: data[2][1:] = tmpData[1:]
        if tmpData[0] == 3: data[3][1:] = tmpData[1:]

    return data


def movAvgRT(data,n):
    if len(data) < n+1:     # '+1' because you have to neglect the initial 0-line!
        print "movAvgRT below!"
        return data[-1]
    else:
        for i in range(3):
            data[-1][i] = np.sum(data[:,i][-n:])/n
        return data[-1]



def moving_average(data, n) :
    """simple moving average filter, returns the filtered data

    Parameters
    ----------
    data : array (shape=(n,1))
        the dataset to be filtered
    n : int
        nr of points used for the avg filter

    Returns
    -------
    dataFiltered : array
        the filtered dataset
    """
    ret = np.cumsum(data, dtype=float, axis=0)
#    print ret

    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n

def moving_average3d(data, n) :
    """simple moving average filter, returns the filtered data
        for measurements with 3 dimensions!

    Parameters
    ----------
    data : array (shape=(n,1))
        the dataset to be filtered
    n : int
        nr of points used for the avg filter

    Returns
    -------
    dataFiltered : array
        the filtered dataset
    """
    ret = []

    for i in range(3):
        tmp = np.cumsum(data[:,i], dtype=float, axis=0)
#    print ret
        tmp[n:] = tmp[n:] - tmp[:-n]

        ret.append(tmp[n-1:]/n)

    mat = np.zeros((len(ret[0]),3))
    mat[:,0] = ret[0]
    mat[:,1] = ret[1]
    mat[:,2] = ret[2]

    return mat


def collectForTime(arg,sec,wait=0.01, fileName=None, avgFil=False, avgN=10):
    """ collect the data of the muxed sensors for a given time interval
        you can end the acquisition at any time, by presseing 'Ctrl-c'

    Parameters
    ----------
    arg : string
        the command to start the subprocess for the data acquistion

    sec : int
        time interval in seconds

    wait : int
        time (in seconds) you wait between you read a new measurement
        (otherwise you will be flooded with equal values), default = 0.01

    fileName : string, optional
        name of the file, to save the data (leave out, if saving is not required)

    avgFil : bool, optional
        whether the moving average filter should be applied, or not

    avgN : int, optional
        the step size of the moving average filter

    Returns
    -------
    out : list
        a list of arrays, each containing the data of one sensor

    """
    subpro = subprocess.Popen(arg.split(),
                            stdout=subprocess.PIPE, close_fds=True)

    collected = np.array([[0,0.,0.,0.],
                         [1,0.,0.,0.],
                         [2,0.,0.,0.],
                         [3,0.,0.,0.]])

    startTime = time.time()

    try:
        print "taking measurements..."
        while time.time()-startTime < sec:
            print time.time()-startTime

            data = readMagPacket(subpro, sensStamp=True)
#            print "data\n",data
            collected = np.append(collected,data,0)



    except KeyboardInterrupt:
        print "interrupted..."

    print "data collected!"
    subpro.terminate()

    out = splitData(eraseZeros(collected))      # split the data in fingers and erase the misstaken measurements

    return out

"""
fitting the data to the model
"""
def getScaleOff(ref,meas):
    scale = np.array([0.,0.,0.])
    res = meas.copy()

    for i in range(0,3):
        raReal = max(ref[:,i]) - min(ref[:,i])
        raMeas = max(meas[:,i]) - min(meas[:,i])
        scale[i] = raReal/raMeas

    offset = np.zeros((3,))
    res *= scale

    for i in range(0,3):
        offset[i] = ref[0][i]-res[0][i]

    res += offset

    print "scale: ",scale
    print "offset: ",offset
    return (scale,offset)


def fitMeasurements(ref, meas, valOffset):
    """returns the measurement data fitted to the reference data

    Parameters
    ----------
    ref : array
        the reference values
    meas : array
        the measured values
    valOffset : tuple
        the values for defining the initial offset (meas[valOffset[0]:valOffset[1]])

    Returns
    -------
    fitted : array
        the fitted measurement data

    """
    scaled = scaleMeasurements(ref, meas)
    fitted = shiftMeasurements(ref, scaled, valOffset)
    return fitted

def scaleMeasurements(real, meas):
    i=0
    raReal=0
    raMeas=0
    scale = np.array([0.,0.,0.])
#    resMat = meas.copy()

    for i in range(3):
        raReal = max(real[:,i]) - min(real[:,i])
        raMeas = max(meas[:,i]) - min(meas[:,i])
        scale[i] = raReal/raMeas
        i+=1
    print "scale ", scale

    meas *= scale

    return meas


def shiftMeasurements(real, meas, valOffset):
    resMat = meas.copy()

    startMat = meas[valOffset[0]:valOffset[1]]
    meanMeas = np.array([np.mean(startMat[:,0]),
                         np.mean(startMat[:,1]),
                         np.mean(startMat[:,2])])
    offset = real[0] - meanMeas

    i=0
    for i in range (resMat.shape[0]):
        resMat[i][0] += offset[0]
        resMat[i][1] += offset[1]
        resMat[i][2] += offset[2]
        i+=1
    print "offset: " + str(offset)
    return resMat


def saveStates(f,data):
    outp = open(f,'w')
    for i in data:
        for e in i:
            outp.write(str(e)+' ')
        outp.write('\n')

    outp.close()


def readStateFile(f):
    inp = open(f,'r')
    lineLen = len((inp.readline().split()))
    res = np.zeros((1,lineLen))

    for i in inp:
        values = np.array(i.split(),dtype=np.float)
        res = np.append(res,np.reshape(values,((1,lineLen))),axis=0)

    return res[1:]
